### 映射（MAP）-归约(REDUCE)：大型集群应用下简化数据解析

#### 摘要

​		**MapReduce** 是一种为解析生成大规模数据集而实现的编程模型。用户指定一个**map**函数，用于解析 **k/v** 键值对数据集并生成新（中间）的 **k/v** 键值对数据集；同时指定 **reduce** 函数用于合并所有包含相同中间键的中间值（新的键值对）。如本文所述，许多现实世界中的任务均可用该模型表述。

​		这种函数式风格的程序会自动并行的运行在大型商业集群环境下。运行系统负责切分输入数据的详情，调度程序在集群机器上执行，处理机器故障及内部机器间的通信。这使没有并行和分布式系统经验的工程师可以轻松利用大型分布式系统的资源。

​		我们实现的 **MapReduce** 运行在大型商业集群环境上，并且可高度扩展；一个典型的 **MapReduce** 计算可以在上千台机器上处理上 **TB** 的数据。工程师发现该系统非常易用：已经实施了数百个 **MapReduce** 程序，并且谷歌的集群上每天都执行着上千的 **MapReduce** 任务。

#### 1. 介绍

​		在过去五年里，作者们在谷歌已经实现了数百种特殊用途的计算，用于处理大量原始数据，比如爬虫文档、**web** 请求日志等。计算各种各样的衍生数据，比如倒排索引、各种 **web** 文档的图行结构声明、每个主机爬取的页面摘要、给定时间的高频查询集合等。大多数此类计算在概念上都是易懂的，然而输入数据通常较大，计算任务不得不被分布到成百上千的机器上保证在适当的时间内去完成。如何保证并行计算、分布数据、故障处理？解决这些问题会产生大量复杂代码并掩盖原本简单的计算操作。

​		为了应对这种复杂性。我们设计了一种能够表述我们试图执行的简单计算的抽象，但是我们将并行计算、容错、数据分布以及负载均衡的细节处理隐藏在库中。我们的抽象灵感来自 **map** 和 **reduce** 在 **Lisp** 和其它函数式编程语言的早期实现。我们意识到大部分计算都涉及对输入数据中的逻辑记录应用 **map** 操作，以便计算得到一组中间 **k/v** 键值对，然后对所有包含相同键的值进行 **reduce** 操作，以便适当的组合这些导出数据。我们对用户自定义的 **map** 和 **reduce** 操作使用函数模型，这使得我们能够轻松的进行大型并行计算，同时让重新执行作为容错的主要机制。

​		这项工作的主要共享是一个简单且强大的接口，这个接口保证了大规模计算的自动并行和分布式操作，结合该接口的实现可以在大规模商业PC机器上保证高性能。

​		第二节描述了编程模型的基础，并给出了几个示例。第三节描述了一个基于集群计算环境下 **MapReduce** 接口的实现。第四节描述了我们针对编程模型已发现的几点有效改进。第五节有针对几项任务的性能衡量。第六节探讨了 **MapReduce** 在 **Google** 中的用法，包括我们使用它作为重写生产索引系统基础的经验。第七节讨论未来相关的工作。

#### 2. 编程模型

​		计算任务接收一个 **k/v** 键值对集合作为输入，并生成一个新的 **k/v** 键值对集合作为输出，**MapReduce** 库通过 **Map** 和 **Reduce** 函数表示计算。

​		用户编写的 **Map** 函数接收一个输入对并生成一个中间的 **k/v** 键值对。**MapReduce ** 库会将所有拥有相同中间键 ***I*** 的中间值分组并传递给 **Reduce ** 函数。

​		**Reduce ** 函数同样由用户编写，该函数接收一个中间键 ***I*** 和与该中间键关联的值集合，它将这些值合并在一起以形成可能较小的一组值。

​		通常一次 **Reduce ** 调用只会生成零个或一个输出值。中间值通过迭代器提供给用户的 **Reduce ** 函数。这使我们能够处理太大而无法容纳在内存中的值列表。

##### 2.1 示例

​		考虑对大量文档中每个单词的出现次数进行计数的问题。用户将编写类似如下的伪代码：

```
map(String key, String value):
    // key: document name
    // value: document contents
    for each word w in value:
        EmitIntermediate(w, "1");

reduce(String key, Iterator values):
    // key: a word
    // values: a list of counts
    int result = 0;
    for each v in values:
        result += ParseInt(v);
        Emit(AsString(result));
```

​		**map** 函数会发出每个单词以及相关的出现次数（在此简单示例中为“ 1”）。**reduce** 函数将针对特定单词发出的所有计数求和。

​		另外，用户编写代码以满足 **MapReduce** 对象规范，其中包含输入和输出文件的名称以及可选的调整参数。然后用户调用 **MapReduce** 函数，并向其传递规范对象。用户的代码被链接到 **MapReduce** 库（由 **C++**实现）。附录A包含本示例的完整代码。

##### 2.2 类型

​		即使前面的伪代码是根据字符串输入和输出编写的，从概念上来说用户提供的 **map** 和 **reduce** 函数具有关联类型：

```
map (k1,v1) → list(k2,v2)
reduce (k2,list(v2)) → list(v2)
```

​		即使输入键值和输出键值是由不同领域描绘的，但是中间键值和输出键值是来自同一领域的。

​		我们的 **C++** 实现将字符串往返传递给用户的自定义函数，并将其留给用户代码，使用户代码能够在字符串和适当的类型间转换。

##### 2.3 更多示例

​		这里有一些有趣且简单的示例，这些示例可以很容易描述 **MapReduce** 计算。

* 分布式 **grep**

  如果与提供的模式匹配，**map** 函数发出一行。**reduce** 函数是一个标识函数，它仅将提供的中间数据复制到输出中。

* 统计 **URL** 访问频率：



#### 3. 实现

##### 3.1 执行概述

##### 3.2 主要数据结构

##### 3.3 容错能力

##### 3.4 区域性

##### 3.5 任务粒度

##### 3.6 任务备份

#### 4. 改进

##### 4.1 分割函数

##### 4.2 顺序保障

##### 4.3 合并函数

##### 4.4 输入输出类型

##### 4.5 副作用

##### 4.6 跳过糟糕记录

##### 4.7 本地执行

##### 4.8 状态信息

##### 4.9 计数器

#### 5. 性能

##### 5.1 集群配置

##### 5.2 搜索

##### 5.3 排序

##### 5.4 任务备份的效果

##### 5.5 机器故障

#### 6. 经验

##### 6.1 大规模索引

#### 7. 相关工作

#### 8. 结论

#### 致谢

#### 引用















